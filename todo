# Mobil Garson Uygulaması (Waiter App) — Geliştirici Rehberi & TODO

Bu doküman mobil garson uygulamasını “hiçbir şey bilmiyor” varsayımıyla baştan anlatır. Amaç: Mevcut POS (Electron + PostgreSQL) backend’ini kullanarak bağımsız mobil (Android öncelikli) bir garson istemcisi geliştirmek.

## 0. Teknoloji Seçimleri
Mobil İstemci:
- Framework: React Native (Expo ile hızlı başlangıç) veya alternatif olarak Flutter (tek kod, yüksek performans). Bu proje için: React Native + TypeScript + Zustand/Redux (hafif state) + react-query (data fetch caching) önerilir.
- Navigasyon: React Navigation (tab + stack).
- HTTP: fetch veya axios (axios zaten projede var, yeniden kullanılabilir).
- WebSocket: socket.io-client (node tarafında socket.io kurulu olacak).
- Güvenli Depolama: expo-secure-store (accessToken & deviceId).

Backend (Mevcut Masaüstü İçinde):
- Express (REST API) — port 4000
- Socket.IO (realtime)
- JSON Web Token (jsonwebtoken)
- Bcrypt (password hashing)
- PostgreSQL (pg)

## 1. Veri Modeli (Önemli Tablolar)
orders(id, table_id, order_type, status, payment_status, total, version, created_at, updated_at)
order_items(id, order_id, menu_item_id, quantity, price, notes, created_at)
tables(id, number, status, category_id, updated_at)
menu_items(id, name, price, category, available, updated_at)
users(id, username, password_hash, role, is_active)
devices(id, name, verification_code, code_expires_at, is_trusted, verified_at)

## 2. Mobilde Görüntülenecek / İşlenecek Alanlar
- Tablo listesi: id, number, status
- Menü: id, name, price, category, available
- Açık sipariş: order.id, status, items[{id, menuItemId, name, quantity, price}], total
- Ödeme ekranı: orderId, kalan tutar, yöntemler (nakit, kredi-karti, ticket, borc)

## 3. API Endpoint Tasarımı (Beklenen)
Auth:
POST /auth/login {username, password} -> {data:{user, tokens:{accessToken}}}

Config / Pairing (gelecek):
POST /config/pair/init (Admin JWT) -> {data:{code, expiresAt}}
POST /config/pair/claim {code, deviceMeta} -> {data:{deviceId}}

Menü & Tablolar:
GET /tables -> {data: Table[]}
GET /menu -> {data:{categories: string[], items: MenuItem[]}}

Siparişler:
GET /orders/open?tableId=ID -> {data: Order | null}
POST /orders {tableId?, orderType, items:[{menuItemId, quantity, notes?}]} -> {data: Order}
POST /orders/:id/items {items:[{menuItemId, quantity, notes?}]} -> {data: Order}
PATCH /orders/:id/status {status, version} -> {data: Order} (409 versiyon uyuşmazlığı)
GET /orders/:id -> {data: Order}

Ödeme:
POST /payments {orderId, method, amount, customerId?} -> {data:{historyId}}

Müşteri (opsiyonel):
GET /customers?search=abc -> {data: Customer[]}

Standart Hata:
{error:{code, message, details?}}

## 4. Realtime (Socket.IO)
Bağlantı: io('http://IP:4000', { autoConnect:false })
1) backend’e bağlanınca client.emit('auth', accessToken)
2) 'auth_ok' bekle; gelmezse 'auth_error'

Event Akışı:
server -> client:
- table:update {id,status}
- order:new {id, tableId, total, status}
- order:update {id,status,total?,version}
- order:item:add {orderId,item:{menuItemId,quantity,price}}
- order:paid {orderId}
- menu:item:update {id,available,price?}

Client Uygulaması state’i event’lerle patch edecek (ör: tables store, orders store).

## 5. React Native Mimari Önerisi
src/
  api/ (restClient.ts, endpoints.ts)
  sockets/ (socket.ts)
  state/ (tablesStore.ts, ordersStore.ts, authStore.ts)
  screens/
    LoginScreen.tsx
    ConfigScreen.tsx
    TablesScreen.tsx
    MenuScreen.tsx
    OrderScreen.tsx
    PaymentScreen.tsx
  components/
  utils/
  types/

restClient.ts (örnek):
```
const BASE = getStoredBaseUrl();
async function api(path: string, opts: RequestInit = {}) {
  const token = await getToken();
  const headers = { 'Content-Type': 'application/json', ...(opts.headers||{}), ...(token?{Authorization:`Bearer ${token}`}:{}) };
  const res = await fetch(BASE+path, { ...opts, headers });
  const json = await res.json().catch(()=>({}));
  if(!res.ok) throw json.error || { code:'HTTP_'+res.status, message:'İstek başarısız'};
  return json.data;
}
export const login = (u:string,p:string)=> api('/auth/login',{method:'POST',body:JSON.stringify({username:u,password:p})});
```

socket.ts (örnek):
```
import { io } from 'socket.io-client';
import { getToken } from '../state/authStore';
export const socket = io(BASE_URL, { autoConnect:false });
export async function connectSocket(){
  if(socket.connected) return;
  socket.connect();
  const token = await getToken();
  socket.on('connect', ()=> socket.emit('auth', token));
}
```

## 6. Order Oluşturma Akışı (Mobil)
1. Kullanıcı tabloyu seçer -> tablesStore.selected = id
2. Menüden ürün ekler -> draftOrderItems[{menuItemId, quantity, price}]
3. Gönder: POST /orders (tableId, items)
4. Dönen Order store’a yazılır, draft temizlenir
5. WebSocket'ten gelecek order:new ile diğer cihazlar senkron olur

## 7. Ödeme Akışı
1. Açık sipariş getir: GET /orders/open?tableId=...
2. Tutar göster
3. Ödeme yöntemi seç + POST /payments
4. Başarılıysa order:paid event veya response -> masa ekranına geri dön + toast

## 8. Optimistic Concurrency
PATCH /orders/:id/status gönderirken mevcut order.version gönder
Backend WHERE id=? AND version=?; günceller version=version+1
Eğer 0 satır -> 409 döner; mobil -> Order yeniden GET eder

## 9. Pairing Akışı (İleride)
Admin masaüstünden pairing code üretir -> Mobil ConfigScreen kullanıcı code girer -> claim -> deviceId saklanır -> future policy: login esnasında X-Device-Id doğrulaması.

## 10. Güvenlik Notları
- Access token’ı yalnız SecureStore’da sakla.
- Hata mesajı kullanıcıya yalın (stack yok).
- Ağ yoksa offline mod yok: kullanıcıya “Sunucuya bağlanılamadı”.

## 11. Yapılacaklar CheckList (Güncel)
Backend (Sunucu):
[ ] Tüm kullanıcılar için toplu password hash script
[ ] /auth/login (mevcut basit) -> role guard (waiter değilse 403?)
[ ] /menu endpoint
[ ] /orders & alt uçlar
[ ] /payments endpoint
[ ] Versiyon kontrollü status update
[ ] WebSocket publish noktaları
[ ] Pairing init & claim uçları (opsiyonel ilk sürümde atlanabilir)
[ ] Standart error middleware
[ ] Rate limit login
[ ] CORS + JWT secret .env

Mobil (React Native):
[ ] Proje bootstrap (Expo + TS)
[ ] ConfigScreen (base URL girişi + test connection /health)
[ ] LoginScreen (POST /auth/login)
[ ] Token saklama + global auth store
[ ] TablesScreen (GET /tables, status renkleri)
[ ] MenuScreen (GET /menu, kategori filtre)
[ ] Order draft state + ürün ekleme
[ ] Submit order (POST /orders)
[ ] OrderScreen (açık sipariş detay + ürün ekle + status değiştir)
[ ] PaymentScreen (POST /payments)
[ ] Socket bağlanma + event handler’lar
[ ] Toast / notification bileşeni
[ ] Hata interceptor (401 -> login)
[ ] Versiyon 409 handling

Test / DoD:
[ ] Masa seç → sipariş oluştur → diğer client’ta event geliyor
[ ] Sipariş status update → event alınır
[ ] Ödeme sonrası masa status available
[ ] Yanlış token -> 401
[ ] Eksik body -> 400
[ ] Versiyon çakışması -> 409 senaryosu

## 12. Örnek API Yanıtları
GET /tables -> {"data":[{"id":1,"number":"1","status":"available"}]}
POST /auth/login -> {"data":{"user":{"id":2,"username":"garson1","role":"waiter"},"tokens":{"accessToken":"<JWT>"}}}
Error örnek -> {"error":{"code":"UNAUTHORIZED","message":"Token gerekli"}}

## 13. İsimlendirme / Kod Standartları
- Dosya adları: camelCase (React bileşenleri PascalCase)
- Tipler: interface IMenuItem yerine MenuItem (basit)
- API dönüşleri daima {data} veya {error}

## 14. Yol Haritası Önerisi (Sprint Bazlı)
S1: Auth + /tables + /menu + mobil login & temel listeler
S2: Orders create / open / status + socket events (table:update, order:new/update)
S3: Payments + order:paid + concurrency
S4: Pairing + device policy + hata standardizasyonu
S5: Performans (caching) + güvenlik (rate limit) + refactor

## 15. Sık Karşılaşılacak Hatalar
- 401: Token süresi dolmuş → tekrar login
- 409: Versiyon çakışması → Order yeniden yüklenir
- 400/422: Body şema uyuşmuyor → Form input kontrol et
- Socket auth_error: Token yanlış veya süresi doldu

## 16. Gelecek Genişlemeler
- Refresh token rotasyonu
- Offline queue (istemiyoruz şu an)
- Stok azaltma / envanter
- Bildirim (push) entegrasyonu

---
Bu rehber mobil geliştiriciye sıfırdan başlamak için yeterli kapsamı sağlar. İlerleme aşamalarında her completed madde checklist’te işaretlenmeli.
